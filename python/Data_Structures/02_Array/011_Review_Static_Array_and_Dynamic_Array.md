# 정적 배열과 동적 배열의 차이점

+ 정적 배열(Static Array)과 동적 배열(Dynamic Array)은 둘 다 데이터를 연속적으로 저장하는 자료 구조지만, 메모리 관리와 유연성에서 큰 차이가 있습니다. 

+ 아래는 두 배열의 주요 차이를 종합적으로 정리한 내용입니다.

## 1. 정의

### 정적 배열 (Static Array):

+ 크기가 고정된 배열로, 선언 시 크기를 지정하며 실행 중에 크기를 변경할 수 없음.

+ 주로 **스택 메모리**(Stack Memory)에 저장됨.

### 동적 배열 (Dynamic Array):

+ 크기가 유동적인 배열로, 실행 중에 크기를 변경하거나 확장 가능.

+ 주로 **힙 메모리**(Heap Memory)에 저장됨.

## 2. 주요 차이점

특성	|정적 배열 (Static Array)|	동적 배열 (Dynamic Array)
|---|---|---|
크기 설정	|선언 시 크기 고정, 실행 중 변경 불가	|실행 중 크기를 변경하거나 확장 가능
메모리 할당	|컴파일 타임에 스택 메모리에서 할당|	실행 중에 힙 메모리에서 동적으로 할당
메모리 효율성	|메모리 낭비 가능성 있음 (미리 설정된 크기가 남을 경우)|	필요한 만큼만 메모리를 사용하여 효율적
초기화 시점	|배열 선언 시 초기화 필수	|런타임에 필요한 시점에서 초기화 가능
유연성	|고정 크기라 유연성 부족	|크기 변경 가능, 유연성 높음
성능	|크기 고정으로 접근 속도가 빠름	|크기 변경 시 복사/재할당 비용 발생 가능
확장/축소|	불가능	|가능 (새로운 메모리를 할당하고 기존 데이터를 복사)
언어 지원	|C, C++, Java 등 대부분의 언어에서 기본 제공	|Java의 ArrayList, Python의 List 등으로 구현됨

## 3. 장단점

### 정적 배열

#### 장점:

+ 메모리가 연속적으로 할당되어 접근 속도가 빠름.

+ 메모리 관리가 간단하며 추가적인 재할당 비용이 없음.

+ 메모리 오버헤드가 적음.

#### 단점:

+ 크기가 고정되어 유연성이 부족.

+ 크기를 초과하거나 낭비가 발생할 가능성.

+ 사용하기 전에 배열 크기를 정확히 알아야 함.

### 동적 배열

#### 장점:

+ 실행 중 크기 조정이 가능해 유연성이 높음.

+ 필요한 만큼 메모리를 할당하므로 효율적.

+ 데이터의 추가, 삽입, 삭제가 용이.

#### 단점:

+ 크기 변경 시 기존 데이터를 복사해야 하므로 성능 저하 가능.

+ 메모리 재할당 과정에서 메모리 단편화 발생 가능.

+ 구현 및 관리가 정적 배열보다 복잡.

## 4. 코드 예시

### 정적 배열 (C)
```c
#include <stdio.h>

int main() {
    int arr[5];  // 크기 고정
    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;  // 값 초기화
    }

    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);  // 출력: 1 2 3 4 5
    }

    return 0;
}
```
### 동적 배열 (C)
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int *)malloc(5 * sizeof(int));  // 동적 메모리 할당
    for (int i = 0; i < 5; i++) {
        arr[i] = i + 1;  // 값 초기화
    }

    arr = (int *)realloc(arr, 10 * sizeof(int));  // 배열 확장
    for (int i = 5; i < 10; i++) {
        arr[i] = i + 1;  // 추가 값 초기화
    }

    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);  // 출력: 1 2 3 4 5 6 7 8 9 10
    }

    free(arr);  // 메모리 해제
    return 0;
}
```
## 5. 사용 사례

### 정적 배열의 사용 사례:

+ 배열의 크기가 미리 고정된 경우(예: 고정 크기의 행렬 계산, 게임 맵 등).

+ 성능이 중요한 작업(메모리 재할당 없이 빠른 실행이 필요한 경우).

### 동적 배열의 사용 사례:

+ 데이터 크기를 미리 알 수 없는 경우(예: 사용자 입력 기반 데이터 저장).

+ 유연성이 중요한 작업(동적으로 데이터를 추가/삭제해야 하는 경우).

# 결론

+ 정적 배열은 고정 크기로 빠르고 단순한 작업에 적합하며, 메모리 효율성이 높습니다.

+ 동적 배열은 크기 조정이 필요하거나 유연성이 중요한 경우에 적합하지만, 크기 변경 시 성능 저하를 고려해야 합니다.

+ 적절한 배열을 선택하려면, 작업의 요구 사항과 성능/메모리 제한을 잘 분석하는 것이 중요합니다. 😊

---

+ Python에서는 정적 배열과 동적 배열을 명시적으로 구분하지는 않습니다.

    + 정적 배열: Python의 array 모듈을 사용하여 고정 크기의 배열을 구현할 수 있습니다.

    + 동적 배열: Python의 리스트(list)는 동적 배열처럼 동작하며 크기를 유동적으로 변경할 수 있습니다.

## 정적 배열 (Python의 array 모듈)

+ array 모듈은 고정된 데이터 타입과 크기를 사용하는 배열을 제공합니다.

### 예시 코드
```python
import array

# 정수형 배열 생성 (정적 배열)
arr = array.array('i', [1, 2, 3, 4, 5])  # 'i'는 정수형 배열을 의미

# 배열 출력
print("정적 배열:", arr)  # 출력: array('i', [1, 2, 3, 4, 5])

# 배열 요소 접근
print("첫 번째 요소:", arr[0])  # 출력: 1

# 배열의 크기 변경 불가
# arr.append(6)  # TypeError: 정적 배열은 크기를 동적으로 확장할 수 없음
```

## 동적 배열 (Python의 리스트)

+ Python의 list는 크기를 동적으로 조정할 수 있어 동적 배열처럼 동작합니다.

### 예시 코드
```python
# 동적 배열 (Python의 리스트)
arr = [1, 2, 3, 4, 5]

# 배열 출력
print("동적 배열:", arr)  # 출력: [1, 2, 3, 4, 5]

# 배열에 요소 추가
arr.append(6)
print("요소 추가 후:", arr)  # 출력: [1, 2, 3, 4, 5, 6]

# 배열 크기 자동 확장
arr.extend([7, 8, 9])
print("확장 후:", arr)  # 출력: [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 배열에서 요소 삭제
arr.pop()
print("요소 삭제 후:", arr)  # 출력: [1, 2, 3, 4, 5, 6, 7, 8]
```

## 정적 배열 vs 동적 배열: 메모리 관리 차이

+ Python 리스트는 내부적으로 동적 배열처럼 동작하며, 다음과 같은 방식으로 메모리를 관리합니다:

    + 요소를 추가할 때, 기존 크기를 초과하면 새로운 메모리를 할당하고 데이터를 복사합니다.

    + 이는 동적 배열의 크기 조정 비용과 동일한 방식입니다.

## 정적 배열과 동적 배열 비교

특성|	정적 배열 (array 모듈)	|동적 배열 (list)
|---|---|---|
크기	|고정 크기	|크기 조정 가능
데이터 타입	|단일 데이터 타입|	다양한 데이터 타입 지원
요소 추가/삭제	|제한적|	자유롭게 추가/삭제 가능
성능	|메모리 사용 효율적	|크기 변경 시 성능 오버헤드 가능

## Python 정적 배열과 동적 배열 활용

+ 정적 배열: 데이터 타입이 고정되고, 크기가 정해진 경우에 적합 (예: 고정 크기 데이터 처리).

+ 동적 배열: 크기가 유동적이고 다양한 데이터 타입을 다루는 경우에 적합.

+ Python에서 대부분의 경우 list를 사용하는 것이 일반적이지만, 특정한 성능 요구 사항이 있다면 array 모듈을 사용할 수 있습니다. 😊

---

# 정적 배열에 삽입, 삭제 연산을 못하는 이유

![Data_Structures_009](../../images/Data_Structures/009.png)
![Data_Structures_010](../../images/Data_Structures/010.png)