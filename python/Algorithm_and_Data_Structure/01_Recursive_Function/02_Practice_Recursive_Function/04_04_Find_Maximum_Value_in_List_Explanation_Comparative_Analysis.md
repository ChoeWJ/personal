# **장단점 비교**

## **1번 코드**

```python
def max_list(my_list):
    # 베이스 케이스
    if len(my_list) == 1:
        return my_list[0]  
    #가장 왼쪽과 오른쪽 값 비교
    elif my_list[0] > my_list[-1]:
        # 가장 왼쪽값이 크면 가장 오른쪽 값 빼고 max_list 함수 호출
        return max_list(my_list[:-1])
    # 가장 오른쪽값이 크면 가장 왼쪽 값 빼고 max_list 함수 호출  
    return max_list(my_list[1:])        
```

### 장점
- 리스트의 양 끝값을 비교하며 최댓값을 찾는 방식이 직관적이고 재귀 구조를 이해하기 쉽다.
- 재귀 호출을 통해 문제를 단계적으로 줄여나가는 구조가 명확하다.

### 단점
- **리스트 슬라이싱 비용**: `my_list[:-1]`와 `my_list[1:]`을 계속 생성하여 **메모리 사용량이 증가**.
- **시간 복잡도**: 리스트 크기가 \(n\)일 때, 슬라이싱으로 인해 \(O(n^2)\)의 비효율적인 시간 복잡도가 발생.

---

## **2번 코드**

```python
def max_list(my_list):
    if len(my_list) == 1:
        return my_list[0]
    
    if my_list[-1] > my_list[0]:
        my_list.pop(0)
    else:
        my_list.pop(-1)
    return max_list(my_list)
```

### 장점
- 슬라이싱 대신 `pop()`을 사용하여 리스트를 직접 수정하므로 **메모리 사용을 줄임**.
- 간단하고 직관적인 방식으로 양쪽 끝값을 비교하며 최댓값을 찾는다.

### 단점
- **원본 리스트 손상**: `pop()`이 원본 리스트를 변경하므로, 함수 호출 후 원본 리스트가 손실된다.
- **시간 복잡도**: `pop(0)`은 리스트의 첫 번째 요소를 제거하며 나머지 요소를 이동시키기 때문에 여전히 \(O(n^2)\).

---

## **3번 코드**

```python
def max_list(my_list):
    # 베이스 케이스
    if len(my_list) == 1:
        return my_list[0]

    # 재귀 케이스
    max_sublist = max_list(my_list[:-1])
    if max_sublist >= my_list[-1]:
        return max_sublist
    else:
        return my_list[-1]
```

### 장점
- 리스트를 한 요소씩 제거하며 재귀적으로 최댓값을 계산하는 **논리적이고 체계적인 구조**.
- 원본 리스트를 수정하지 않고, 슬라이싱만 사용하여 **원본 데이터를 유지**.

### 단점
- **슬라이싱 비용**: `my_list[:-1]`로 리스트 복사를 계속 수행하므로 **메모리 비효율성**이 존재.
- **시간 복잡도**: \(O(n^2)\)의 비효율적인 성능.

---

## **결론**
- **최적의 구현**: 
  반복문을 사용한 방식이 가장 효율적이며, 시간 복잡도 \(O(n)\)와 메모리 효율성 측면에서 우수하다.
- **재귀적 구현**: 
  학습 목적으로 재귀를 사용하고 싶다면, 3번 코드가 가장 적합하다. 다만, 슬라이싱에 따른 성능 비용을 고려해야 한다.

## **권장 방식**
반복문을 활용한 최적화된 구현이 실용적이며, 대규모 데이터에서도 효율적인 성능을 보장한다.

---
## **1번, 2번, 3번 코드의 순위 비교**

### **효율성과 메모리 사용량 기준**
1. **2번 코드 (가장 효과적)**:
   - 슬라이싱 대신 `pop()`을 사용하여 메모리 사용량이 적다.
   - 리스트를 직접 수정하며 최댓값을 찾기 때문에 슬라이싱 비용이 없다.
   - 단, 원본 리스트를 변경한다는 점에서 순수성이 떨어지지만, 성능 면에서는 가장 효율적이다.

2. **3번 코드**:
   - 원본 리스트를 유지하며 재귀적으로 최댓값을 찾는다.
   - 그러나 슬라이싱을 사용하기 때문에 메모리 사용량이 증가하고 성능이 2번 코드보다 낮다.
   - 재귀를 이해하는 데는 적합하다.

3. **1번 코드 (가장 비효율적)**:
   - 슬라이싱을 반복적으로 사용하며 새로운 리스트를 생성한다.
   - 슬라이싱 비용이 많이 발생하므로 메모리 사용량이 가장 많다.
   - 성능 측면에서 가장 비효율적이다.

---

## **최적의 정답: 반복문을 사용한 모범 예시**
재귀 대신 반복문을 사용하면 메모리 사용량을 최소화하고 성능도 최적화할 수 있다. 다음은 최적의 구현이다:

```python
def max_list(my_list):
    max_value = my_list[0]  # 리스트의 첫 번째 값을 초기 최댓값으로 설정
    for num in my_list[1:]:  # 나머지 값을 순회
        if num > max_value:
            max_value = num  # 더 큰 값을 만나면 갱신
    return max_value
```

## **재귀적 방법으로 최적의 구현**
슬라이싱으로 인한 메모리 비효율성을 피하기 위해, 인덱스를 활용한 재귀적인 접근 방식을 사용합니다. 이 방식은 추가 메모리 사용을 줄이고 원본 리스트를 수정하지 않으면서도 효율적인 재귀를 구현합니다.

```python
def max_list_recursive(my_list, start=0, end=None):
    if end is None:
        end = len(my_list) - 1  # 초기 종료 인덱스를 리스트 길이로 설정

    # 베이스 케이스: 리스트에 하나의 요소만 남은 경우
    if start == end:
        return my_list[start]

    # 가장 왼쪽(start)과 가장 오른쪽(end)을 비교하며 범위를 줄임
    if my_list[start] > my_list[end]:
        return max_list_recursive(my_list, start, end - 1)
    else:
        return max_list_recursive(my_list, start + 1, end)
```
## **구현 방식**
### **매개변수 추가**:
- `start`: 비교를 시작할 인덱스.
- `end`: 비교를 종료할 인덱스.

이 방식은 리스트를 슬라이싱하지 않고 `start`와 `end`로 범위를 축소하여 메모리 효율성을 개선합니다.

---

## **장점**
1. **메모리 효율성**:
   - 슬라이싱 대신 인덱스를 사용하므로 추가 리스트 생성이 필요 없음.
2. **원본 리스트 유지**:
   - 원본 리스트를 수정하지 않고 그대로 유지.
3. **재귀적 사고 유지**:
   - 재귀 호출을 통해 단계적으로 범위를 줄이는 방식이 명확하고 직관적.

---

## **단점**
1. **코드 복잡성 증가**:
   - 추가 매개변수(`start`, `end`)로 인해 코드가 약간 복잡해질 수 있음.
2. **스택 오버플로우 가능성**:
   - 리스트가 너무 크면 재귀 깊이에 제한이 있어 문제가 발생할 수 있음.

---

## **결론**
이 구현은 재귀를 유지하면서도 슬라이싱을 피하여 메모리 효율성을 높인 방식입니다. 학습 목적으로 재귀를 활용하면서도 실용적인 코드를 작성하고 싶을 때 적합한 모범적인 예시입니다.
