# 1. 알고리즘의 수학적 복잡성 이유

## 1. 입력 크기에 따른 변화

+ 알고리즘은 일반적으로 입력 크기에 따라 성능(시간 및 공간 복잡도)이 달라집니다. 

+ 이를 분석하기 위해 수학적 모델링과 성장률(예: Big-O 표기법)이 필요합니다.

+ 예를 들어, 
$O(n), O(n^2), O(2^n)$와 같은 *시간 복잡도 분석*은 `점근적 표기법`을 사용하여 입력 크기가 증가할 때 성능 변화를 예측합니다.

## 2. 조합적 문제

+ 조합적 문제에서는 **가능한 모든 경우의 수를 탐색**해야 하며, 경우의 수가 기하급수적으로 증가하기 때문에 수학적 도구가 필수적입니다.

+ 예: 배낭 문제 (Knapsack Problem), 여행 판매원 문제 (TSP) 등.

## 3. 확률과 통계

+ 일부 알고리즘은 랜덤성이나 확률적 과정을 사용합니다. 

+ 예를 들어, 몬테카를로 알고리즘은 확률론을 기반으로 합니다.

## 4. 최적화 문제

+ 최적화 문제는 가능한 해 중에서 최적의 해를 찾는 문제로, 종종 복잡한 함수 최적화(예: 그래디언트 계산, 라그랑주 승수법 등)가 필요합니다.

## 5. 수학적 증명

+ 알고리즘의 정확성과 효율성을 증명하려면 수학적 귀납법, 그래프 이론, 군론 등의 다양한 수학 기법이 필요합니다.

---

# 2. 수학적으로 복잡한 알고리즘의 예

## 1. 다익스트라 알고리즘 (Dijkstra's Algorithm)

+ 문제: 그래프에서 단일 출발점에서 모든 정점으로의 최단 경로를 찾는 문제.

+ 수학적 복잡성:

    + 그래프 이론(정점, 간선, 가중치).

    + 최단 경로의 존재와 가중치가 음수가 아닐 때의 최적성 증명.

    + $O(V^2) 또는 O(VlogV + E)$ 복잡도를 분석

+ 필요한 수학:

    + 행렬 대수(인접 행렬 표현).

    + 그래프 이론.

    + 점근적 분석(Big-O).

## 2. 여행 판매원 문제 (TSP)

+ 문제: 주어진 도시를 모두 방문하고 처음으로 돌아오는 최단 경로를 찾는 문제.

+ 수학적 복잡성:

    + 경우의 수가  $n!$로 증가하는 NP-완전 문제.

    + 동적 계획법 또는 분지 한정(branch-and-bound) 방식으로 해결.

+ 필요한 수학:

    + 조합론.

    + 최적화 이론(예: 선형 계획법).

    + 그래프 이론.
     
## 3. 머신 러닝 알고리즘

+ 예: 선형 회귀, 신경망 학습.

+ 수학적 복잡성:

    + 선형 회귀는 최소제곱법으로 최적의 모델을 학습합니다.

    + 신경망 학습에서는 경사 하강법(Gradient Descent)을 사용하여 손실 함수 최적화.

+ 필요한 수학:

    + 선형 대수(행렬 연산).

    + 미적분학(기울기 계산).

    + 확률론(최소화 문제에서 노이즈 처리).

## 4. FFT(Fast Fourier Transform)

+ 문제: 시간 복잡도 $O(n^2)$인 이산 푸리에 변환(DFT)을 $O(nlogn)$으로 개선.

+ 수학적 복잡성:

    + 복소수와 주기성 함수 분석.

    + 분할 정복 기법.

+ 필요한 수학:

    + 복소수(지수 함수 표현).

    + 선형 대수.

    + 분할 정복 알고리즘.

---

# 3. 알고리즘 설계와 분석에 필요한 수학

+ ## 기초 수학
    
    + 대수학: 알고리즘에서 수식 계산이나 변수 변환에 사용.
    
    + 수열과 급수: 점근적 성능 분석.

+ ## 이산 수학
    
    + 그래프 이론: 그래프 기반 알고리즘(DFS, BFS, 최소 신장 트리 등).
    
    + 조합론: 경우의 수 계산과 최적화 문제(예: 배낭 문제).
    
    + 집합론: 데이터 구조(해시 테이블, 유니언-파인드 등).

+ ## 선형 대수

    + 벡터와 행렬을 사용하는 알고리즘(예: 머신 러닝, 추천 시스템).

+ ## 미적분학

    + 최적화 문제에서 손실 함수 최소화.

    + 연속적 변화 분석(예: 경사 하강법).
+ ## 확률과 통계

    + 랜덤 알고리즘 분석 및 몬테카를로 시뮬레이션.

+ ## 점근적 분석

    + 알고리즘의 성능을 빅오 표기법으로 분석.

---

# 4. 알고리즘 설계에서 수학을 사용하는 예

+ ## 이진 탐색

    + 시간 복잡도 분석: 로그 함수 $O(logn)$

    + 수학적 증명: 귀납법으로 알고리즘의 올바름 증명.
+ ## 퀵 정렬

    + 평균 시간 복잡도 분석: 수학적 기대값 $O(nlogn)$

    + 분할 정복 원리.